
<!DOCTYPE html>

<html>

<head>
<style>
	#info {
		position: absolute;
		top: 100px; width: 100%;
		color: #ffff00;
		text-align: center;
	}
	#deviceInfo {
		position: absolute;
		bottom: 100px; width: 100%;
		color: #ffffff;
		text-align: center;
	}

</style>
</head>

<body> 
<div id='info'> Device Orientation </div>
<div id='deviceInfo'></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script>
// new contact problem:
// static XZ plane
// moving gravity vector (subject to deviceOrientation)
// add shadow map
// add border first ....
//

var camera, scene, renderer, light;
var ball, ball2, plane;
var clock = new THREE.Clock();
var mouse = new THREE.Vector2();
var gravity = new THREE.Vector3();
var deviceInfo, gamma = 0, beta = 0;

// class definitions here
var Ball = function (c,x,y) {
    // properties
    this.pos = new THREE.Vector3(x, 0, y);
    this.vel = new THREE.Vector3();
    this.force = new THREE.Vector3();
    this.mesh = new THREE.Mesh(new THREE.SphereGeometry(10, 32, 32), new THREE.MeshPhongMaterial({
        color: c,
        specular: 0x444444,
        shininess: 80
    }));
    scene.add(this.mesh);

    // methods
    this.update = function (dt) {
        this.vel.add(this.force.clone().multiplyScalar(dt));
        this.pos.add(this.vel.clone().multiplyScalar(dt));
        this.mesh.position.copy(this.pos);
	
        // border check
        if (this.pos.x > 90) {
            this.pos.setX (90);
            this.vel.setX (0);
        } else if (this.pos.x < -90) {
            this.pos.setX (-90);
            this.vel.setX (0);
        }
        if (this.pos.z > 90) {
            this.pos.setZ (90);
            this.vel.setZ (0);
        } else if (this.pos.z < -90) {
            this.pos.setZ (-90);
            this.vel.setZ (0);
        }
    }
}

var Plane = function () {
    // properties
    this.pos = new THREE.Vector3(0, 10, 0); // object frame
    this.normal = new THREE.Vector3(0, 1, 0); // object frame
    this.mesh = new THREE.Mesh(new THREE.BoxGeometry(500, 20, 500), new THREE.MeshLambertMaterial({
        transparent: true,
        opacity: 0.5
    }));
    scene.add(this.mesh);
	
    // methods
    this.isPointOut = function (point) {
        // considering plane transformation
        var posW = this.pos.clone(); // in world frame
        var normalW = this.normal.clone();
        posW.applyMatrix4(this.mesh.matrixWorld);
        var tt = new THREE.Matrix4();
        normalW.applyMatrix4(tt.getInverse(this.mesh.matrixWorld).transpose());

        return true; // for infinite plane
        // for contact problem, this should check whether the ball
        // rolls out of boundary
    }
};

function buildWall(){
	let obj = new THREE.Object3D();
	let mesh1 = new THREE.Mesh(new THREE.BoxGeometry(220,50,10),new THREE.MeshPhongMaterial({color:0x9e7032}));
	mesh1.position.set(0,25,-105);
	obj.add(mesh1);
	let mesh2 = new THREE.Mesh(new THREE.BoxGeometry(220,50,10),new THREE.MeshPhongMaterial({color:0x9e7032}));
	mesh2.position.set(0,25,105);
	obj.add(mesh2);
	let mesh3 = new THREE.Mesh(new THREE.BoxGeometry(10,50,220),new THREE.MeshPhongMaterial({color:0x9e7032}));
	mesh3.position.set(105,25,0);
	obj.add(mesh3);
	let mesh4 = new THREE.Mesh(new THREE.BoxGeometry(10,50,220),new THREE.MeshPhongMaterial({color:0x9e7032}));
	mesh4.position.set(-105,25,0);
	obj.add(mesh4);
	let mesh5 = new THREE.Mesh(new THREE.BoxGeometry(220,1,220),new THREE.MeshPhongMaterial({color:0xf9a41b}));
	mesh5.position.set(0,0,0);
	obj.add(mesh5);
	let mesh6 = new THREE.Mesh(new THREE.BoxGeometry(120,50,10),new THREE.MeshPhongMaterial({color:0xb7771f}));
	mesh6.position.set(0,25,0);
	obj.add(mesh6);
	let mesh7 = new THREE.Mesh(new THREE.BoxGeometry(10,50,140),new THREE.MeshPhongMaterial({color:0xb7771f}));
	mesh7.position.set(0,25,-30);
	obj.add(mesh7);
	let mesh8 = new THREE.Mesh(new THREE.BoxGeometry(10,50,120),new THREE.MeshPhongMaterial({color:0xb7771f}));
	mesh8.position.set(60,25,0);
	obj.add(mesh8);
	let mesh9 = new THREE.Mesh(new THREE.BoxGeometry(10,50,120),new THREE.MeshPhongMaterial({color:0xb7771f}));
	mesh9.position.set(-60,25,0);
	obj.add(mesh9);
	let mesh10 = new THREE.Mesh(new THREE.CircleGeometry(10,32),new THREE.MeshBasicMaterial({color:0x42321c}));
	mesh10.rotation.x = -Math.PI / 2;
	mesh10.position.set(30,2,80);
	obj.add(mesh10);
	let mesh11 = mesh10.clone();
	mesh11.position.set(-90,2,-90);
	obj.add(mesh11);
	let mesh12 = mesh10.clone();
	mesh12.position.set(-90,2,90);
	obj.add(mesh12);
	let mesh13 = mesh10.clone();
	mesh13.position.set(-75,2,0);
	obj.add(mesh13);
	let mesh14 = mesh10.clone();
	mesh14.position.set(-30,2,80);
	obj.add(mesh14);
	let mesh15 = mesh10.clone();
	mesh15.position.set(90,2,90);
	obj.add(mesh15);
	let mesh16 = mesh10.clone();
	mesh16.position.set(90,2,-90);
	obj.add(mesh16);
	let mesh17 = mesh10.clone();
	mesh17.position.set(75,2,0);
	obj.add(mesh17);
	let mesh18 = new THREE.Mesh(new THREE.CircleGeometry(10,32),new THREE.MeshBasicMaterial({color:0x881234}));
	mesh18.rotation.x = -Math.PI / 2;
	mesh18.position.set(30,2,20);
	obj.add(mesh18);
	let mesh19 = new THREE.Mesh(new THREE.CircleGeometry(10,32),new THREE.MeshBasicMaterial({color:0x128888}));
	mesh19.rotation.x = -Math.PI / 2;
	mesh19.position.set(-30,2,20);
	obj.add(mesh19);
	scene.add(obj);
}


init();
animate();

function init() {

	// assume the plane is XZ plane
	// with normal = (0,1,0)
    scene = new THREE.Scene();

    camera = new THREE.OrthographicCamera(-120, 120, 120, -120, 10, 2000);
    camera.position.set(0, 450, 0);
    camera.up.set(0, 0, -1);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(camera);

    ball = new Ball(0xff1234,-30,-30);
	ball2 = new Ball(0x12ffff,30,-30);

    light = new THREE.PointLight(0xffffff);
    light.position.set(0, 300, 0);
    scene.add(light);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);

    var gridXZ = new THREE.GridHelper(200, 10, 'red', 'white');
    scene.add(gridXZ);
    scene.add (new THREE.AxisHelper (30))

    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize, false);
//    document.addEventListener('mousemove', onDocumentMouseMove, false);
    deviceInfo = document.getElementById('deviceInfo');

	window.addEventListener('deviceorientation', function(e) {
		gamma = e.gamma;
		beta = e.beta;
		console.log (gamma +', ' + beta + ', ' + e.alpha);
	});
	
	buildWall();
	
}

/*
function onDocumentMouseMove(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1; // [-1,1]
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // active gamma & beta: [-90,90]
    gamma = mouse.x*90;
    beta = -mouse.y*90;

	//console.log (gamma + ', ' + beta);
    // mouse.x is gamma (rotation about Y)
}
*/

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function Contact(ball, plane) {

    ball.pos.setY(0); // ball position correction
    let normalW = new THREE.Vector3(0, 1, 0); // local plane normal
 	
	ball.force.copy (gravity.projectOnPlane (normalW));
}

function animate() {
    //deviceInfo.innerHTML = '[gamma: ' + gamma.toFixed(2) + '], [beta: ' 
    //    + beta.toFixed(2) +']';

    // euler: in radian
    // gamma/beta: in degree
    // device beta (DeviceX) correspond to world X
    // device gamma (DeviceY) correspond to world -Z
	//beta=5,gamma=-10;
	var a = new THREE.Euler(-beta*Math.PI/180, 0, gamma*Math.PI/180, 'XYZ');
    gravity = new THREE.Vector3(0, -180, 0);
    gravity.applyEuler(a);
	 
    Contact(ball, plane);
	let dt = clock.getDelta();
    ball.update(dt);
	
	Contact(ball2, plane);
	//let dt = clock.getDelta();
    ball2.update(dt);

    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}
</script>
</body>

</html>
